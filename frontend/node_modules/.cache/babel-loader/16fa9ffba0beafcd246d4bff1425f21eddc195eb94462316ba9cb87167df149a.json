{"ast":null,"code":"\"use client\";\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// src/index.tsx\nimport { cloneElement, isValidElement, useCallback, useEffect as useEffect2, useReducer, useRef as useRef2, useState } from \"react\";\nimport convert2 from \"react-from-dom\";\n\n// src/config.ts\nvar CACHE_NAME = \"react-inlinesvg\";\nvar CACHE_MAX_RETRIES = 10;\nvar STATUS = {\n  IDLE: \"idle\",\n  LOADING: \"loading\",\n  LOADED: \"loaded\",\n  FAILED: \"failed\",\n  READY: \"ready\",\n  UNSUPPORTED: \"unsupported\"\n};\n\n// src/modules/helpers.ts\nfunction canUseDOM() {\n  return !!(typeof window !== \"undefined\" && window.document && window.document.createElement);\n}\nfunction isSupportedEnvironment() {\n  return supportsInlineSVG() && typeof window !== \"undefined\" && window !== null;\n}\nasync function request(url, options) {\n  const response = await fetch(url, options);\n  const contentType = response.headers.get(\"content-type\");\n  const [fileType] = (contentType ?? \"\").split(/ ?; ?/);\n  if (response.status > 299) {\n    throw new Error(\"Not found\");\n  }\n  if (![\"image/svg+xml\", \"text/plain\"].some(d => fileType.includes(d))) {\n    throw new Error(`Content type isn't valid: ${fileType}`);\n  }\n  return response.text();\n}\nfunction sleep(seconds = 1) {\n  return new Promise(resolve => {\n    setTimeout(resolve, seconds * 1e3);\n  });\n}\nfunction supportsInlineSVG() {\n  if (!document) {\n    return false;\n  }\n  const div = document.createElement(\"div\");\n  div.innerHTML = \"<svg />\";\n  const svg = div.firstChild;\n  return !!svg && svg.namespaceURI === \"http://www.w3.org/2000/svg\";\n}\nfunction randomCharacter(character) {\n  return character[Math.floor(Math.random() * character.length)];\n}\nfunction randomString(length) {\n  const letters = \"abcdefghijklmnopqrstuvwxyz\";\n  const numbers = \"1234567890\";\n  const charset = `${letters}${letters.toUpperCase()}${numbers}`;\n  let R = \"\";\n  for (let index = 0; index < length; index++) {\n    R += randomCharacter(charset);\n  }\n  return R;\n}\nfunction omit(input, ...filter) {\n  const output = {};\n  for (const key in input) {\n    if ({}.hasOwnProperty.call(input, key)) {\n      if (!filter.includes(key)) {\n        output[key] = input[key];\n      }\n    }\n  }\n  return output;\n}\n\n// src/modules/cache.ts\nvar CacheStore = class {\n  constructor() {\n    __publicField(this, \"cacheApi\");\n    __publicField(this, \"cacheStore\");\n    __publicField(this, \"subscribers\", []);\n    __publicField(this, \"isReady\", false);\n    this.cacheStore = /* @__PURE__ */new Map();\n    let cacheName = CACHE_NAME;\n    let usePersistentCache = false;\n    if (canUseDOM()) {\n      cacheName = window.REACT_INLINESVG_CACHE_NAME ?? CACHE_NAME;\n      usePersistentCache = !!window.REACT_INLINESVG_PERSISTENT_CACHE && \"caches\" in window;\n    }\n    if (usePersistentCache) {\n      caches.open(cacheName).then(cache => {\n        this.cacheApi = cache;\n        this.isReady = true;\n        this.subscribers.forEach(callback => callback());\n      }).catch(error => {\n        this.isReady = true;\n        console.error(`Failed to open cache: ${error.message}`);\n      });\n    } else {\n      this.isReady = true;\n    }\n  }\n  onReady(callback) {\n    if (this.isReady) {\n      callback();\n    } else {\n      this.subscribers.push(callback);\n    }\n  }\n  async get(url, fetchOptions) {\n    await (this.cacheApi ? this.fetchAndAddToPersistentCache(url, fetchOptions) : this.fetchAndAddToInternalCache(url, fetchOptions));\n    return this.cacheStore.get(url)?.content ?? \"\";\n  }\n  set(url, data) {\n    this.cacheStore.set(url, data);\n  }\n  isCached(url) {\n    return this.cacheStore.get(url)?.status === STATUS.LOADED;\n  }\n  async fetchAndAddToInternalCache(url, fetchOptions) {\n    const cache = this.cacheStore.get(url);\n    if (cache?.status === STATUS.LOADING) {\n      await this.handleLoading(url, async () => {\n        this.cacheStore.set(url, {\n          content: \"\",\n          status: STATUS.IDLE\n        });\n        await this.fetchAndAddToInternalCache(url, fetchOptions);\n      });\n      return;\n    }\n    if (!cache?.content) {\n      this.cacheStore.set(url, {\n        content: \"\",\n        status: STATUS.LOADING\n      });\n      try {\n        const content = await request(url, fetchOptions);\n        this.cacheStore.set(url, {\n          content,\n          status: STATUS.LOADED\n        });\n      } catch (error) {\n        this.cacheStore.set(url, {\n          content: \"\",\n          status: STATUS.FAILED\n        });\n        throw error;\n      }\n    }\n  }\n  async fetchAndAddToPersistentCache(url, fetchOptions) {\n    const cache = this.cacheStore.get(url);\n    if (cache?.status === STATUS.LOADED) {\n      return;\n    }\n    if (cache?.status === STATUS.LOADING) {\n      await this.handleLoading(url, async () => {\n        this.cacheStore.set(url, {\n          content: \"\",\n          status: STATUS.IDLE\n        });\n        await this.fetchAndAddToPersistentCache(url, fetchOptions);\n      });\n      return;\n    }\n    this.cacheStore.set(url, {\n      content: \"\",\n      status: STATUS.LOADING\n    });\n    const data = await this.cacheApi?.match(url);\n    if (data) {\n      const content = await data.text();\n      this.cacheStore.set(url, {\n        content,\n        status: STATUS.LOADED\n      });\n      return;\n    }\n    try {\n      await this.cacheApi?.add(new Request(url, fetchOptions));\n      const response = await this.cacheApi?.match(url);\n      const content = (await response?.text()) ?? \"\";\n      this.cacheStore.set(url, {\n        content,\n        status: STATUS.LOADED\n      });\n    } catch (error) {\n      this.cacheStore.set(url, {\n        content: \"\",\n        status: STATUS.FAILED\n      });\n      throw error;\n    }\n  }\n  async handleLoading(url, callback) {\n    let retryCount = 0;\n    while (this.cacheStore.get(url)?.status === STATUS.LOADING && retryCount < CACHE_MAX_RETRIES) {\n      await sleep(0.1);\n      retryCount += 1;\n    }\n    if (retryCount >= CACHE_MAX_RETRIES) {\n      await callback();\n    }\n  }\n  keys() {\n    return [...this.cacheStore.keys()];\n  }\n  data() {\n    return [...this.cacheStore.entries()].map(([key, value]) => ({\n      [key]: value\n    }));\n  }\n  async delete(url) {\n    if (this.cacheApi) {\n      await this.cacheApi.delete(url);\n    }\n    this.cacheStore.delete(url);\n  }\n  async clear() {\n    if (this.cacheApi) {\n      const keys = await this.cacheApi.keys();\n      for (const key of keys) {\n        await this.cacheApi.delete(key);\n      }\n    }\n    this.cacheStore.clear();\n  }\n};\n\n// src/modules/hooks.tsx\nimport { useEffect, useRef } from \"react\";\nfunction usePrevious(state) {\n  const ref = useRef();\n  useEffect(() => {\n    ref.current = state;\n  });\n  return ref.current;\n}\n\n// src/modules/utils.ts\nimport convert from \"react-from-dom\";\nfunction getNode(options) {\n  const {\n    baseURL,\n    content,\n    description,\n    handleError,\n    hash,\n    preProcessor,\n    title,\n    uniquifyIDs = false\n  } = options;\n  try {\n    const svgText = processSVG(content, preProcessor);\n    const node = convert(svgText, {\n      nodeOnly: true\n    });\n    if (!node || !(node instanceof SVGSVGElement)) {\n      throw new Error(\"Could not convert the src to a DOM Node\");\n    }\n    const svg = updateSVGAttributes(node, {\n      baseURL,\n      hash,\n      uniquifyIDs\n    });\n    if (description) {\n      const originalDesc = svg.querySelector(\"desc\");\n      if (originalDesc?.parentNode) {\n        originalDesc.parentNode.removeChild(originalDesc);\n      }\n      const descElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"desc\");\n      descElement.innerHTML = description;\n      svg.prepend(descElement);\n    }\n    if (typeof title !== \"undefined\") {\n      const originalTitle = svg.querySelector(\"title\");\n      if (originalTitle?.parentNode) {\n        originalTitle.parentNode.removeChild(originalTitle);\n      }\n      if (title) {\n        const titleElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"title\");\n        titleElement.innerHTML = title;\n        svg.prepend(titleElement);\n      }\n    }\n    return svg;\n  } catch (error) {\n    return handleError(error);\n  }\n}\nfunction processSVG(content, preProcessor) {\n  if (preProcessor) {\n    return preProcessor(content);\n  }\n  return content;\n}\nfunction updateSVGAttributes(node, options) {\n  const {\n    baseURL = \"\",\n    hash,\n    uniquifyIDs\n  } = options;\n  const replaceableAttributes = [\"id\", \"href\", \"xlink:href\", \"xlink:role\", \"xlink:arcrole\"];\n  const linkAttributes = [\"href\", \"xlink:href\"];\n  const isDataValue = (name, value) => linkAttributes.includes(name) && (value ? !value.includes(\"#\") : false);\n  if (!uniquifyIDs) {\n    return node;\n  }\n  [...node.children].forEach(d => {\n    if (d.attributes?.length) {\n      const attributes = Object.values(d.attributes).map(a => {\n        const attribute = a;\n        const match = /url\\((.*?)\\)/.exec(a.value);\n        if (match?.[1]) {\n          attribute.value = a.value.replace(match[0], `url(${baseURL}${match[1]}__${hash})`);\n        }\n        return attribute;\n      });\n      replaceableAttributes.forEach(r => {\n        const attribute = attributes.find(a => a.name === r);\n        if (attribute && !isDataValue(r, attribute.value)) {\n          attribute.value = `${attribute.value}__${hash}`;\n        }\n      });\n    }\n    if (d.children.length) {\n      return updateSVGAttributes(d, options);\n    }\n    return d;\n  });\n  return node;\n}\n\n// src/index.tsx\nimport { jsx } from \"react/jsx-runtime\";\nvar cacheStore;\nfunction ReactInlineSVG(props) {\n  const {\n    cacheRequests = true,\n    children = null,\n    description,\n    fetchOptions,\n    innerRef,\n    loader = null,\n    onError,\n    onLoad,\n    src,\n    title,\n    uniqueHash\n  } = props;\n  const [state, setState] = useReducer((previousState2, nextState) => ({\n    ...previousState2,\n    ...nextState\n  }), {\n    content: \"\",\n    element: null,\n    isCached: cacheRequests && cacheStore.isCached(props.src),\n    status: STATUS.IDLE\n  });\n  const {\n    content,\n    element,\n    isCached,\n    status\n  } = state;\n  const previousProps = usePrevious(props);\n  const previousState = usePrevious(state);\n  const hash = useRef2(uniqueHash ?? randomString(8));\n  const isActive = useRef2(false);\n  const isInitialized = useRef2(false);\n  const handleError = useCallback(error => {\n    if (isActive.current) {\n      setState({\n        status: error.message === \"Browser does not support SVG\" ? STATUS.UNSUPPORTED : STATUS.FAILED\n      });\n      onError?.(error);\n    }\n  }, [onError]);\n  const handleLoad = useCallback((loadedContent, hasCache = false) => {\n    if (isActive.current) {\n      setState({\n        content: loadedContent,\n        isCached: hasCache,\n        status: STATUS.LOADED\n      });\n    }\n  }, []);\n  const fetchContent = useCallback(async () => {\n    const responseContent = await request(src, fetchOptions);\n    handleLoad(responseContent);\n  }, [fetchOptions, handleLoad, src]);\n  const getElement = useCallback(() => {\n    try {\n      const node = getNode({\n        ...props,\n        handleError,\n        hash: hash.current,\n        content\n      });\n      const convertedElement = convert2(node);\n      if (!convertedElement || !isValidElement(convertedElement)) {\n        throw new Error(\"Could not convert the src to a React element\");\n      }\n      setState({\n        element: convertedElement,\n        status: STATUS.READY\n      });\n    } catch (error) {\n      handleError(new Error(error.message));\n    }\n  }, [content, handleError, props]);\n  const getContent = useCallback(async () => {\n    const dataURI = /^data:image\\/svg[^,]*?(;base64)?,(.*)/u.exec(src);\n    let inlineSrc;\n    if (dataURI) {\n      inlineSrc = dataURI[1] ? window.atob(dataURI[2]) : decodeURIComponent(dataURI[2]);\n    } else if (src.includes(\"<svg\")) {\n      inlineSrc = src;\n    }\n    if (inlineSrc) {\n      handleLoad(inlineSrc);\n      return;\n    }\n    try {\n      if (cacheRequests) {\n        const cachedContent = await cacheStore.get(src, fetchOptions);\n        handleLoad(cachedContent, true);\n      } else {\n        await fetchContent();\n      }\n    } catch (error) {\n      handleError(error);\n    }\n  }, [cacheRequests, fetchContent, fetchOptions, handleError, handleLoad, src]);\n  const load = useCallback(async () => {\n    if (isActive.current) {\n      setState({\n        content: \"\",\n        element: null,\n        isCached: false,\n        status: STATUS.LOADING\n      });\n    }\n  }, []);\n  useEffect2(() => {\n    isActive.current = true;\n    if (!canUseDOM() || isInitialized.current) {\n      return () => void 0;\n    }\n    try {\n      if (status === STATUS.IDLE) {\n        if (!isSupportedEnvironment()) {\n          throw new Error(\"Browser does not support SVG\");\n        }\n        if (!src) {\n          throw new Error(\"Missing src\");\n        }\n        load();\n      }\n    } catch (error) {\n      handleError(error);\n    }\n    isInitialized.current = true;\n    return () => {\n      isActive.current = false;\n    };\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  useEffect2(() => {\n    if (!canUseDOM()) {\n      return;\n    }\n    if (!previousProps) {\n      return;\n    }\n    if (previousProps.src !== src) {\n      if (!src) {\n        handleError(new Error(\"Missing src\"));\n        return;\n      }\n      load();\n    } else if (previousProps.title !== title || previousProps.description !== description) {\n      getElement();\n    }\n  }, [description, getElement, handleError, load, previousProps, src, title]);\n  useEffect2(() => {\n    if (!previousState) {\n      return;\n    }\n    if (previousState.status !== STATUS.LOADING && status === STATUS.LOADING) {\n      getContent();\n    }\n    if (previousState.status !== STATUS.LOADED && status === STATUS.LOADED) {\n      getElement();\n    }\n    if (previousState.status !== STATUS.READY && status === STATUS.READY) {\n      onLoad?.(src, isCached);\n    }\n  }, [getContent, getElement, isCached, onLoad, previousState, src, status]);\n  const elementProps = omit(props, \"baseURL\", \"cacheRequests\", \"children\", \"description\", \"fetchOptions\", \"innerRef\", \"loader\", \"onError\", \"onLoad\", \"preProcessor\", \"src\", \"title\", \"uniqueHash\", \"uniquifyIDs\");\n  if (!canUseDOM()) {\n    return loader;\n  }\n  if (element) {\n    return cloneElement(element, {\n      ref: innerRef,\n      ...elementProps\n    });\n  }\n  if ([STATUS.UNSUPPORTED, STATUS.FAILED].includes(status)) {\n    return children;\n  }\n  return loader;\n}\nfunction InlineSVG(props) {\n  if (!cacheStore) {\n    cacheStore = new CacheStore();\n  }\n  const {\n    loader\n  } = props;\n  const hasCallback = useRef2(false);\n  const [isReady, setReady] = useState(cacheStore.isReady);\n  useEffect2(() => {\n    if (!hasCallback.current) {\n      cacheStore.onReady(() => {\n        setReady(true);\n      });\n      hasCallback.current = true;\n    }\n  }, []);\n  if (!isReady) {\n    return loader;\n  }\n  return /* @__PURE__ */jsx(ReactInlineSVG, {\n    ...props\n  });\n}\nexport { cacheStore, InlineSVG as default };","map":{"version":3,"names":["cloneElement","isValidElement","useCallback","useEffect","useEffect2","useReducer","useRef","useRef2","useState","convert2","CACHE_NAME","CACHE_MAX_RETRIES","STATUS","IDLE","LOADING","LOADED","FAILED","READY","UNSUPPORTED","canUseDOM","window","document","createElement","isSupportedEnvironment","supportsInlineSVG","request","url","options","response","fetch","contentType","headers","get","fileType","split","status","Error","some","d","includes","text","sleep","seconds","Promise","resolve","setTimeout","div","innerHTML","svg","firstChild","namespaceURI","randomCharacter","character","Math","floor","random","length","randomString","letters","numbers","charset","toUpperCase","R","index","omit","input","filter","output","key","hasOwnProperty","call","CacheStore","constructor","__publicField","cacheStore","Map","cacheName","usePersistentCache","REACT_INLINESVG_CACHE_NAME","REACT_INLINESVG_PERSISTENT_CACHE","caches","open","then","cache","cacheApi","isReady","subscribers","forEach","callback","catch","error","console","message","onReady","push","fetchOptions","fetchAndAddToPersistentCache","fetchAndAddToInternalCache","content","set","data","isCached","handleLoading","match","add","Request","retryCount","keys","entries","map","value","delete","clear","usePrevious","state","ref","current","convert","getNode","baseURL","description","handleError","hash","preProcessor","title","uniquifyIDs","svgText","processSVG","node","nodeOnly","SVGSVGElement","updateSVGAttributes","originalDesc","querySelector","parentNode","removeChild","descElement","createElementNS","prepend","originalTitle","titleElement","replaceableAttributes","linkAttributes","isDataValue","name","children","attributes","Object","values","a","attribute","exec","replace","r","find","jsx","ReactInlineSVG","props","cacheRequests","innerRef","loader","onError","onLoad","src","uniqueHash","setState","previousState2","nextState","element","previousProps","previousState","isActive","isInitialized","handleLoad","loadedContent","hasCache","fetchContent","responseContent","getElement","convertedElement","getContent","dataURI","inlineSrc","atob","decodeURIComponent","cachedContent","load","elementProps","InlineSVG","hasCallback","setReady"],"sources":["/Users/samfriedman/Documents/sloper_items/react_ui_sloper/frontend/node_modules/react-inlinesvg/src/index.tsx","/Users/samfriedman/Documents/sloper_items/react_ui_sloper/frontend/node_modules/react-inlinesvg/src/config.ts","/Users/samfriedman/Documents/sloper_items/react_ui_sloper/frontend/node_modules/react-inlinesvg/src/modules/helpers.ts","/Users/samfriedman/Documents/sloper_items/react_ui_sloper/frontend/node_modules/react-inlinesvg/src/modules/cache.ts","/Users/samfriedman/Documents/sloper_items/react_ui_sloper/frontend/node_modules/react-inlinesvg/src/modules/hooks.tsx","/Users/samfriedman/Documents/sloper_items/react_ui_sloper/frontend/node_modules/react-inlinesvg/src/modules/utils.ts"],"sourcesContent":["import {\n  cloneElement,\n  isValidElement,\n  ReactElement,\n  useCallback,\n  useEffect,\n  useReducer,\n  useRef,\n  useState,\n} from 'react';\nimport convert from 'react-from-dom';\n\nimport { STATUS } from './config';\nimport CacheStore from './modules/cache';\nimport { canUseDOM, isSupportedEnvironment, omit, randomString, request } from './modules/helpers';\nimport { usePrevious } from './modules/hooks';\nimport { getNode } from './modules/utils';\nimport { FetchError, Props, State, Status } from './types';\n\n// eslint-disable-next-line import/no-mutable-exports\nexport let cacheStore: CacheStore;\n\nfunction ReactInlineSVG(props: Props) {\n  const {\n    cacheRequests = true,\n    children = null,\n    description,\n    fetchOptions,\n    innerRef,\n    loader = null,\n    onError,\n    onLoad,\n    src,\n    title,\n    uniqueHash,\n  } = props;\n  const [state, setState] = useReducer(\n    (previousState: State, nextState: Partial<State>) => ({\n      ...previousState,\n      ...nextState,\n    }),\n    {\n      content: '',\n      element: null,\n\n      isCached: cacheRequests && cacheStore.isCached(props.src),\n      status: STATUS.IDLE,\n    },\n  );\n  const { content, element, isCached, status } = state;\n  const previousProps = usePrevious(props);\n  const previousState = usePrevious(state);\n\n  const hash = useRef(uniqueHash ?? randomString(8));\n  const isActive = useRef(false);\n  const isInitialized = useRef(false);\n\n  const handleError = useCallback(\n    (error: Error | FetchError) => {\n      if (isActive.current) {\n        setState({\n          status:\n            error.message === 'Browser does not support SVG' ? STATUS.UNSUPPORTED : STATUS.FAILED,\n        });\n\n        onError?.(error);\n      }\n    },\n    [onError],\n  );\n\n  const handleLoad = useCallback((loadedContent: string, hasCache = false) => {\n    if (isActive.current) {\n      setState({\n        content: loadedContent,\n        isCached: hasCache,\n        status: STATUS.LOADED,\n      });\n    }\n  }, []);\n\n  const fetchContent = useCallback(async () => {\n    const responseContent: string = await request(src, fetchOptions);\n\n    handleLoad(responseContent);\n  }, [fetchOptions, handleLoad, src]);\n\n  const getElement = useCallback(() => {\n    try {\n      const node = getNode({ ...props, handleError, hash: hash.current, content }) as Node;\n      const convertedElement = convert(node);\n\n      if (!convertedElement || !isValidElement(convertedElement)) {\n        throw new Error('Could not convert the src to a React element');\n      }\n\n      setState({\n        element: convertedElement,\n        status: STATUS.READY,\n      });\n    } catch (error: any) {\n      handleError(new Error(error.message));\n    }\n  }, [content, handleError, props]);\n\n  const getContent = useCallback(async () => {\n    const dataURI = /^data:image\\/svg[^,]*?(;base64)?,(.*)/u.exec(src);\n    let inlineSrc;\n\n    if (dataURI) {\n      inlineSrc = dataURI[1] ? window.atob(dataURI[2]) : decodeURIComponent(dataURI[2]);\n    } else if (src.includes('<svg')) {\n      inlineSrc = src;\n    }\n\n    if (inlineSrc) {\n      handleLoad(inlineSrc);\n\n      return;\n    }\n\n    try {\n      if (cacheRequests) {\n        const cachedContent = await cacheStore.get(src, fetchOptions);\n\n        handleLoad(cachedContent, true);\n      } else {\n        await fetchContent();\n      }\n    } catch (error: any) {\n      handleError(error);\n    }\n  }, [cacheRequests, fetchContent, fetchOptions, handleError, handleLoad, src]);\n\n  const load = useCallback(async () => {\n    if (isActive.current) {\n      setState({\n        content: '',\n        element: null,\n        isCached: false,\n        status: STATUS.LOADING,\n      });\n    }\n  }, []);\n\n  // Run on mount\n  useEffect(\n    () => {\n      isActive.current = true;\n\n      if (!canUseDOM() || isInitialized.current) {\n        return () => undefined;\n      }\n\n      try {\n        if (status === STATUS.IDLE) {\n          if (!isSupportedEnvironment()) {\n            throw new Error('Browser does not support SVG');\n          }\n\n          if (!src) {\n            throw new Error('Missing src');\n          }\n\n          load();\n        }\n      } catch (error: any) {\n        handleError(error);\n      }\n\n      isInitialized.current = true;\n\n      return () => {\n        isActive.current = false;\n      };\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [],\n  );\n\n  // Handle prop changes\n  useEffect(() => {\n    if (!canUseDOM()) {\n      return;\n    }\n\n    if (!previousProps) {\n      return;\n    }\n\n    if (previousProps.src !== src) {\n      if (!src) {\n        handleError(new Error('Missing src'));\n\n        return;\n      }\n\n      load();\n    } else if (previousProps.title !== title || previousProps.description !== description) {\n      getElement();\n    }\n  }, [description, getElement, handleError, load, previousProps, src, title]);\n\n  // handle state\n  useEffect(() => {\n    if (!previousState) {\n      return;\n    }\n\n    if (previousState.status !== STATUS.LOADING && status === STATUS.LOADING) {\n      getContent();\n    }\n\n    if (previousState.status !== STATUS.LOADED && status === STATUS.LOADED) {\n      getElement();\n    }\n\n    if (previousState.status !== STATUS.READY && status === STATUS.READY) {\n      onLoad?.(src, isCached);\n    }\n  }, [getContent, getElement, isCached, onLoad, previousState, src, status]);\n\n  const elementProps = omit(\n    props,\n    'baseURL',\n    'cacheRequests',\n    'children',\n    'description',\n    'fetchOptions',\n    'innerRef',\n    'loader',\n    'onError',\n    'onLoad',\n    'preProcessor',\n    'src',\n    'title',\n    'uniqueHash',\n    'uniquifyIDs',\n  );\n\n  if (!canUseDOM()) {\n    return loader;\n  }\n\n  if (element) {\n    return cloneElement(element as ReactElement, { ref: innerRef, ...elementProps });\n  }\n\n  if (([STATUS.UNSUPPORTED, STATUS.FAILED] as Status[]).includes(status)) {\n    return children;\n  }\n\n  return loader;\n}\n\nexport default function InlineSVG(props: Props) {\n  if (!cacheStore) {\n    cacheStore = new CacheStore();\n  }\n\n  const { loader } = props;\n  const hasCallback = useRef(false);\n  const [isReady, setReady] = useState(cacheStore.isReady);\n\n  useEffect(() => {\n    if (!hasCallback.current) {\n      cacheStore.onReady(() => {\n        setReady(true);\n      });\n\n      hasCallback.current = true;\n    }\n  }, []);\n\n  if (!isReady) {\n    return loader;\n  }\n\n  return <ReactInlineSVG {...props} />;\n}\n\nexport * from './types';\n","export const CACHE_NAME = 'react-inlinesvg';\nexport const CACHE_MAX_RETRIES = 10;\n\nexport const STATUS = {\n  IDLE: 'idle',\n  LOADING: 'loading',\n  LOADED: 'loaded',\n  FAILED: 'failed',\n  READY: 'ready',\n  UNSUPPORTED: 'unsupported',\n} as const;\n","import type { PlainObject } from '../types';\n\nexport function canUseDOM(): boolean {\n  return !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n}\n\nexport function isSupportedEnvironment(): boolean {\n  return supportsInlineSVG() && typeof window !== 'undefined' && window !== null;\n}\n\nexport async function request(url: string, options?: RequestInit) {\n  const response = await fetch(url, options);\n  const contentType = response.headers.get('content-type');\n  const [fileType] = (contentType ?? '').split(/ ?; ?/);\n\n  if (response.status > 299) {\n    throw new Error('Not found');\n  }\n\n  if (!['image/svg+xml', 'text/plain'].some(d => fileType.includes(d))) {\n    throw new Error(`Content type isn't valid: ${fileType}`);\n  }\n\n  return response.text();\n}\n\nexport function sleep(seconds = 1) {\n  return new Promise(resolve => {\n    setTimeout(resolve, seconds * 1000);\n  });\n}\n\nexport function supportsInlineSVG(): boolean {\n  /* c8 ignore next 3 */\n  if (!document) {\n    return false;\n  }\n\n  const div = document.createElement('div');\n\n  div.innerHTML = '<svg />';\n  const svg = div.firstChild as SVGSVGElement;\n\n  return !!svg && svg.namespaceURI === 'http://www.w3.org/2000/svg';\n}\n\nfunction randomCharacter(character: string) {\n  return character[Math.floor(Math.random() * character.length)];\n}\n\nexport function randomString(length: number): string {\n  const letters = 'abcdefghijklmnopqrstuvwxyz';\n  const numbers = '1234567890';\n  const charset = `${letters}${letters.toUpperCase()}${numbers}`;\n\n  let R = '';\n\n  for (let index = 0; index < length; index++) {\n    R += randomCharacter(charset);\n  }\n\n  return R;\n}\n\n/**\n *  Remove properties from an object\n */\nexport function omit<T extends PlainObject, K extends keyof T>(\n  input: T,\n  ...filter: K[]\n): Omit<T, K> {\n  const output: any = {};\n\n  for (const key in input) {\n    if ({}.hasOwnProperty.call(input, key)) {\n      if (!filter.includes(key as unknown as K)) {\n        output[key] = input[key];\n      }\n    }\n  }\n\n  return output as Omit<T, K>;\n}\n","import { canUseDOM, request, sleep } from './helpers';\n\nimport { CACHE_MAX_RETRIES, CACHE_NAME, STATUS } from '../config';\nimport { StorageItem } from '../types';\n\nexport default class CacheStore {\n  private cacheApi: Cache | undefined;\n  private readonly cacheStore: Map<string, StorageItem>;\n  private readonly subscribers: Array<() => void> = [];\n  public isReady = false;\n\n  constructor() {\n    this.cacheStore = new Map<string, StorageItem>();\n\n    let cacheName = CACHE_NAME;\n    let usePersistentCache = false;\n\n    if (canUseDOM()) {\n      cacheName = window.REACT_INLINESVG_CACHE_NAME ?? CACHE_NAME;\n      usePersistentCache = !!window.REACT_INLINESVG_PERSISTENT_CACHE && 'caches' in window;\n    }\n\n    if (usePersistentCache) {\n      caches\n        .open(cacheName)\n        .then(cache => {\n          this.cacheApi = cache;\n          this.isReady = true;\n\n          this.subscribers.forEach(callback => callback());\n        })\n        .catch(error => {\n          this.isReady = true;\n\n          // eslint-disable-next-line no-console\n          console.error(`Failed to open cache: ${error.message}`);\n        });\n    } else {\n      this.isReady = true;\n    }\n  }\n\n  public onReady(callback: () => void) {\n    if (this.isReady) {\n      callback();\n    } else {\n      this.subscribers.push(callback);\n    }\n  }\n\n  public async get(url: string, fetchOptions?: RequestInit) {\n    await (this.cacheApi\n      ? this.fetchAndAddToPersistentCache(url, fetchOptions)\n      : this.fetchAndAddToInternalCache(url, fetchOptions));\n\n    return this.cacheStore.get(url)?.content ?? '';\n  }\n\n  public set(url: string, data: StorageItem) {\n    this.cacheStore.set(url, data);\n  }\n\n  public isCached(url: string) {\n    return this.cacheStore.get(url)?.status === STATUS.LOADED;\n  }\n\n  private async fetchAndAddToInternalCache(url: string, fetchOptions?: RequestInit) {\n    const cache = this.cacheStore.get(url);\n\n    if (cache?.status === STATUS.LOADING) {\n      await this.handleLoading(url, async () => {\n        this.cacheStore.set(url, { content: '', status: STATUS.IDLE });\n        await this.fetchAndAddToInternalCache(url, fetchOptions);\n      });\n\n      return;\n    }\n\n    if (!cache?.content) {\n      this.cacheStore.set(url, { content: '', status: STATUS.LOADING });\n\n      try {\n        const content = await request(url, fetchOptions);\n\n        this.cacheStore.set(url, { content, status: STATUS.LOADED });\n      } catch (error: any) {\n        this.cacheStore.set(url, { content: '', status: STATUS.FAILED });\n        throw error;\n      }\n    }\n  }\n\n  private async fetchAndAddToPersistentCache(url: string, fetchOptions?: RequestInit) {\n    const cache = this.cacheStore.get(url);\n\n    if (cache?.status === STATUS.LOADED) {\n      return;\n    }\n\n    if (cache?.status === STATUS.LOADING) {\n      await this.handleLoading(url, async () => {\n        this.cacheStore.set(url, { content: '', status: STATUS.IDLE });\n        await this.fetchAndAddToPersistentCache(url, fetchOptions);\n      });\n\n      return;\n    }\n\n    this.cacheStore.set(url, { content: '', status: STATUS.LOADING });\n\n    const data = await this.cacheApi?.match(url);\n\n    if (data) {\n      const content = await data.text();\n\n      this.cacheStore.set(url, { content, status: STATUS.LOADED });\n\n      return;\n    }\n\n    try {\n      await this.cacheApi?.add(new Request(url, fetchOptions));\n\n      const response = await this.cacheApi?.match(url);\n      const content = (await response?.text()) ?? '';\n\n      this.cacheStore.set(url, { content, status: STATUS.LOADED });\n    } catch (error: any) {\n      this.cacheStore.set(url, { content: '', status: STATUS.FAILED });\n      throw error;\n    }\n  }\n\n  private async handleLoading(url: string, callback: () => Promise<void>) {\n    let retryCount = 0;\n\n    while (this.cacheStore.get(url)?.status === STATUS.LOADING && retryCount < CACHE_MAX_RETRIES) {\n      // eslint-disable-next-line no-await-in-loop\n      await sleep(0.1);\n      retryCount += 1;\n    }\n\n    if (retryCount >= CACHE_MAX_RETRIES) {\n      await callback();\n    }\n  }\n\n  public keys(): Array<string> {\n    return [...this.cacheStore.keys()];\n  }\n\n  public data(): Array<Record<string, StorageItem>> {\n    return [...this.cacheStore.entries()].map(([key, value]) => ({ [key]: value }));\n  }\n\n  public async delete(url: string) {\n    if (this.cacheApi) {\n      await this.cacheApi.delete(url);\n    }\n\n    this.cacheStore.delete(url);\n  }\n\n  public async clear() {\n    if (this.cacheApi) {\n      const keys = await this.cacheApi.keys();\n\n      for (const key of keys) {\n        // eslint-disable-next-line no-await-in-loop\n        await this.cacheApi.delete(key);\n      }\n    }\n\n    this.cacheStore.clear();\n  }\n}\n","import { useEffect, useRef } from 'react';\n\nexport function usePrevious<T>(state: T): T | undefined {\n  const ref = useRef<T>();\n\n  useEffect(() => {\n    ref.current = state;\n  });\n\n  return ref.current;\n}\n","import convert from 'react-from-dom';\n\nimport { Props, State } from '../types';\n\ninterface GetNodeOptions extends Props, Pick<State, 'content'> {\n  handleError: (error: Error) => void;\n  hash: string;\n}\n\ninterface UpdateSVGAttributesOptions extends Pick<Props, 'baseURL' | 'uniquifyIDs'> {\n  hash: string;\n}\n\nexport function getNode(options: GetNodeOptions) {\n  const {\n    baseURL,\n    content,\n    description,\n    handleError,\n    hash,\n    preProcessor,\n    title,\n    uniquifyIDs = false,\n  } = options;\n\n  try {\n    const svgText = processSVG(content, preProcessor);\n    const node = convert(svgText, { nodeOnly: true });\n\n    if (!node || !(node instanceof SVGSVGElement)) {\n      throw new Error('Could not convert the src to a DOM Node');\n    }\n\n    const svg = updateSVGAttributes(node, { baseURL, hash, uniquifyIDs });\n\n    if (description) {\n      const originalDesc = svg.querySelector('desc');\n\n      if (originalDesc?.parentNode) {\n        originalDesc.parentNode.removeChild(originalDesc);\n      }\n\n      const descElement = document.createElementNS('http://www.w3.org/2000/svg', 'desc');\n\n      descElement.innerHTML = description;\n      svg.prepend(descElement);\n    }\n\n    if (typeof title !== 'undefined') {\n      const originalTitle = svg.querySelector('title');\n\n      if (originalTitle?.parentNode) {\n        originalTitle.parentNode.removeChild(originalTitle);\n      }\n\n      if (title) {\n        const titleElement = document.createElementNS('http://www.w3.org/2000/svg', 'title');\n\n        titleElement.innerHTML = title;\n        svg.prepend(titleElement);\n      }\n    }\n\n    return svg;\n  } catch (error: any) {\n    return handleError(error);\n  }\n}\n\nexport function processSVG(content: string, preProcessor?: Props['preProcessor']) {\n  if (preProcessor) {\n    return preProcessor(content);\n  }\n\n  return content;\n}\n\nexport function updateSVGAttributes(\n  node: SVGSVGElement,\n  options: UpdateSVGAttributesOptions,\n): SVGSVGElement {\n  const { baseURL = '', hash, uniquifyIDs } = options;\n  const replaceableAttributes = ['id', 'href', 'xlink:href', 'xlink:role', 'xlink:arcrole'];\n  const linkAttributes = ['href', 'xlink:href'];\n  const isDataValue = (name: string, value: string) =>\n    linkAttributes.includes(name) && (value ? !value.includes('#') : false);\n\n  if (!uniquifyIDs) {\n    return node;\n  }\n\n  [...node.children].forEach(d => {\n    if (d.attributes?.length) {\n      const attributes = Object.values(d.attributes).map(a => {\n        const attribute = a;\n        const match = /url\\((.*?)\\)/.exec(a.value);\n\n        if (match?.[1]) {\n          attribute.value = a.value.replace(match[0], `url(${baseURL}${match[1]}__${hash})`);\n        }\n\n        return attribute;\n      });\n\n      replaceableAttributes.forEach(r => {\n        const attribute = attributes.find(a => a.name === r);\n\n        if (attribute && !isDataValue(r, attribute.value)) {\n          attribute.value = `${attribute.value}__${hash}`;\n        }\n      });\n    }\n\n    if (d.children.length) {\n      return updateSVGAttributes(d as SVGSVGElement, options);\n    }\n\n    return d;\n  });\n\n  return node;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}